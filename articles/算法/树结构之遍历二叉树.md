# 树结构之遍历二叉树

+ 层序遍历
+ 前序遍历
+ 中序遍历
+ 后序遍历

## 层序遍历

### 递归

### 迭代

```js
function levelIteration(root) {
    let ret = [];
    let stack = [];
    if (root) {
        stack.push(root);
    }
    while(stack.length) {
        let len = stack.length;
        for(var i = 0; i < len; i++) {
            let node = stack.pop();
            ret.push(node.val);
            if(node.left) {
                stack.push(node.left);
            }
            if(node.right) {
                stack.push(node.right);
            }
        }
    }
    return ret;
}
```

### 应用

虚拟dom的diff算法

## 前序遍历

### 递归

```js
function preOrderRecursion(root) {
    if(!root) {
        return [];
    }
    return [root, ...postOrderRecursion(root.left), ...postOrderRecursion(root.right)];
}
```

### 迭代

```js
function preOrderIteration(root) {
    let ret = [];
    let stack = [];
    let node = root;
    while(node || stack.length) {
        while(node) {
            ret.push(node.val);
            if (node.right) {
                stack.push(node.right);
            }
            node = node.left;
        }
        node = stack.pop();
        ret.push(node.val);
    }
    return ret;
}
```

### 应用

## 中序遍历

### 递归

```js
function inOrderRecursion(root) {
    if(!root) {
        return [];
    }
    return [...postOrderRecursion(root.left), root, ...postOrderRecursion(root.right)];
}
```

### 迭代

```js
function inOrderIteration(root) {
    let ret = [];
    let stack = [];
    let node = root;
    while(node || stack.length) {
        while(node) {
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        ret.push(node.val);
        node = node.right;
    }
    return ret;
}
```

### 应用

## 后序遍历

### 递归

```js
function postOrderRecursion(root) {
    if(!root) {
        return [];
    }
    return [...postOrderRecursion(root.left), ...postOrderRecursion(root.right), root];
}
```

### 迭代

```js
function postOrderIteration(root) {
    let ret = [];
    let stack = [];
    let node = root;
    let prev = null;
    while(node || stack.length) {
        while(node) {
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        if(node.right && node.right !== prev) {
            stack.push(node);
            node = node.right;
        }else {
            ret.push(node.val);
            prev = node;
            node = null;
        }
    }
    return ret;
}
```

### 应用
